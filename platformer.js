function updateLevel() {
  if(Level===1){
    level=
   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,2,0,0,0,0,0,0,0,0,0,0,0,0,9,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
    LevelAmount+=1;
    reset();
    map();
  }else if(Level===2){
    level=
   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1],
    [1,2,0,0,0,0,1,1,1,0,0,0,0,0,9,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
    LevelAmount+=1;
    reset();
    map();
  }else if(Level===3){
    level=
   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1],
    [1,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1],
    [1,2,0,1,1,1,1,1,1,1,0,0,0,0,9,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
    LevelAmount+=1;
    reset();
    map();
  }else if(Level===4){
    level=
   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,2,0,0,0,0,0,0,3,0,0,0,0,0,9,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
    LevelAmount+=1;
    reset();
    map();
  }else if(Level===5){
    level=
   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,0,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
    LevelAmount+=1;
    reset();
    map();
  }else if(Level===6){
    level=
   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,2,0,0,0,0,0,0,0,0,0,0,0,0,9,1],
    [1,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1]];
    LevelAmount+=1;
    reset();
    map();
  }else if(Level===7){
    level=
   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1],
    [1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1],
    [1,2,0,0,0,0,0,0,0,0,0,0,0,1,9,1],
    [1,1,3,3,3,3,3,3,3,3,3,3,3,3,3,1]];
    LevelAmount+=1;
    reset();
    map();
  }else{
    console.log(Level);
    level=
   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
    reset();
    map();
  }
}

//does requestAnimationFrame if the browzer allows it otherwise it uses setInterval
(function() {
    var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
    window.requestAnimationFrame = requestAnimationFrame;
})();
var canvas = document.getElementById("canvas"),
ctx = canvas.getContext("2d"),
//create width and height of canvas
width = 640,
height = 560,
//give starting player properties
keys = [],
friction = 0.8,
gravity = 0.3;
//set width and height of canvas
canvas.width = width;
canvas.height = height;
var Level=0;
var LevelAmount=0;
var type="";
var level=[];
var platforms = [];
var players=[];
var blocks = [];
var lava = [];
var portals = [];
var spikes=[];
var blockSize=40;
// works for rectangles
var collide=function(obj1,obj2){
    if( obj1.x<obj2.x+obj2.w&&obj1.x+obj1.w>obj2.x&&
        obj1.y<obj2.y+obj2.h&&obj1.y+obj1.h>obj2.y)
    {
        return true;   
    }    
};
// Player Object
var Player=function(x,y){
    this.x=x;
    this.y=y;
    this.w=blockSize;
    this.h=blockSize;
    
    this.velx=0;
    this.vely=0;
    
    this.moveSpeed=2;
    this.maxSpeed=4;
    
    this.falling=false;
    this.gravity=0.4;
    this.color="red";
    this.dead="false";
    this.health=this.w;
};

Player.prototype.update=function(platforms){
    // key inputs and there responses
    if(keys[38] || keys[32]){
      if(!this.falling){
        this.vely=-8;
        this.falling=true;
      }
    }
    if(keys[39]){
        this.velx+=this.moveSpeed;
        this.frame+=this.frameSpeed;
        this.direction="right";
    }
    
    if(keys[37]){
      
        this.velx-=this.moveSpeed;
        this.frame+=this.frameSpeed;
        this.direction="left";
        
    }
    
    // if the right input key and the left input key are not pressed, decrease the velocity until it comes to a complete stop
    if(!keys[37]&&
        !keys[39])
    {
        if(this.velx>0){
            this.velx-=this.moveSpeed;
        }
        if(this.velx<0){
            this.velx+=this.moveSpeed;
        }
    }

    // limit the player's speed
    if(this.velx>this.maxSpeed){
        this.velx=this.maxSpeed;
    }
    if(this.velx<-this.maxSpeed){
        this.velx=-this.maxSpeed;
    }
    if(this.vely>12){
        this.vely=12;
    }
    
    // update the x and y positions
    this.x+=this.velx;
    this.applyCollision(blocks,this.velx,0);
    this.applyCollision(lava,this.velx,0);
    this.applyCollision(spikes,this.velx,0);

    this.falling=true;
    this.y+=this.vely;
    this.applyCollision(blocks,0,this.vely);
    this.applyCollision(lava,this.vely,0);
    this.applyCollision(spikes,this.vely,0);
    this.vely+=this.gravity;

    this.applyCollision(portals,0,0);
};

Player.prototype.applyCollision=function(platforms,velx,vely){
  if(platforms===blocks){
    for(var i=0; i<platforms.length; i++){
        if(collide(this,platforms[i]))
        {
            if(vely>0){
                this.vely=0;
                this.falling=false;
                this.y=platforms[i].y-this.h;
            }
            if(vely<0){
                this.vely=0;
                this.falling=true;
                this.y=platforms[i].y+platforms[i].h;
            }
            if(velx<0){
                this.velx=0;
                this.x=platforms[i].x+platforms[i].w;
            }
            if(velx>0){
                this.velx=0;
                this.x=platforms[i].x-this.w;
            }
        }
    }
  }else if(platforms===lava){
    for(var i=0; i<platforms.length; i++){
        if(collide(this,platforms[i]))
        {
            this.health-=2;
            type="lava";
        }
    }
  }
  else if(platforms===portals){
    for(var i=0; i<platforms.length; i++){
        if(collide(this,platforms[i]))
        {
            Level++;
            updateLevel();
        }
    }
  }
  else if(platforms===spikes){
    for(var i=0; i<platforms.length; i++){
        if(collide(this,platforms[i]))
        {
            this.dead=true;
        }
    }
  }
};

Player.prototype.draw= function() {
    // draw the player
    ctx.fillStyle=this.color;
    ctx.fill();
    ctx.fillRect(this.x,this.y,this.w,this.h,10);
    ctx.fillStyle="green";
    ctx.fillRect(this.x,this.y-20,this.health,10,10);
};
players.apply=function(blocks){
    for(var i=0; i<players.length; i++){
        players[i].draw();
        players[i].update(blocks);
    }
};
// Block Object
var Block=function(x,y,color){
    this.x=x;
    this.y=y;
    this.w=blockSize;
    this.h=blockSize;
    this.color="black";
};

Block.prototype.draw= function() {
    ctx.fillStyle=this.color;
    ctx.fill();
    ctx.fillRect(this.x,this.y,blockSize,blockSize);
};
var Lava=function(x,y,color){
    this.x=x;
    this.y=y;
    this.w=blockSize;
    this.h=blockSize;
    this.color="darkred";
};
Lava.prototype.draw= function() {
    
    ctx.fill();
    ctx.fillStyle=this.color;
    ctx.fillRect(this.x,this.y,blockSize,blockSize);
};
var Spike=function(x,y,color){
    this.x=x;
    this.y=y;
    this.w=blockSize;
    this.h=blockSize;
    this.color="black";
};
Spike.prototype.draw= function() {
    ctx.beginPath();
    
    ctx.moveTo(this.x,this.y+blockSize);
    ctx.lineTo(this.w+this.x,this.y+blockSize);
    ctx.lineTo((this.x*2+blockSize)/2,this.y);
    ctx.fill();
    ctx.fillStyle = this.color;
    ctx.closePath();
};
var Portal=function(x,y,color){
    this.x=x;
    this.y=y;
    this.w=blockSize;
    this.h=blockSize;
    this.color="blue";
};
Portal.prototype.draw= function() {
    
    ctx.fill();
    ctx.fillStyle=this.color;
    ctx.fillRect(this.x,this.y,blockSize,blockSize);
};
platforms.add=function(type,obj,x,y,w,h){
    type.push(new obj(x,y,w,h));
}
platforms.apply=function(type){
    for(var i=0; i<type.length; i++){
        platforms.push(type[i]);
        type[i].draw();
    }
};

function update(){
  if(Level>0){
    console.log(Level);
    console.log(LevelAmount);
    ctx.clearRect(0, 0, width, height);
  players.apply(platforms);
  platforms.apply(blocks);
  platforms.apply(lava);
  platforms.apply(spikes);
  platforms.apply(portals);
  ctx.fillStyle="black";
  checkDeath();
  }else if(Level===0){
    ctx.fillStyle="green";
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle="black";
    ctx.font = "90px Arial";
    ctx.fillText("Platformer",130,200);
    button(280,350,200,100,"Start","grey","40px Arial",340);
  }
    // run through the loop again
    requestAnimationFrame(update);
}
function getMousePos(canvas, event) {
    var rect = canvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}

function button(x,y,w,h,text,color,textSettings,textX) {
  ctx.fillStyle=color;
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle="black";
  ctx.font = textSettings;
  ctx.fillText(text,textX,y+h/1.6);
}
function isInside(pos, x,y,w,h){
    return pos.x > x && pos.x < x+w && pos.y < y+h && pos.y > y
}
function checkDeath(){
  for (var i = 0; i < players.length; i++) {
    if(players[i].health<=0){
      players[i].health=0;
      players[i].dead=true;
      Level=-1;
      updateLevel();
    }
  }
  if(Level===-1){
    ctx.fillStyle="red";
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle="black";
    ctx.font = "50px Arial";
    ctx.fillText("You died from "+type,100,300);
    button(280,350,200,100,"Restart","grey","40px Arial",320);
  }else if(Level>LevelAmount){
    ctx.fillStyle="black";
    ctx.font = "100px Arial";
    ctx.fillText("You Won",130,300);
  }
}
function reset() {
  platforms = [];
  players=[];
  blocks = [];
  lava = [];
  portals = [];
  spikes = [];
  players.apply=function(blocks){
    for(var i=0; i<players.length; i++){
        players[i].draw();
        players[i].update(blocks);
    }
  };
  platforms.add=function(type,obj,x,y,w,h){
    type.push(new obj(x,y,w,h));
  };
    platforms.apply=function(type){
    for(var i=0; i<type.length; i++){
        platforms.push(type[i]);
        type[i].draw();
    }
    };
}
function map() {
    // this is the code that reads the levels:
    // for loop for y axis
    for(var col=0; col<level.length; col++){
    // for loop for x axis
    for(var row=0; row<level[col].length; row++){
        if(level[col][row]===0){
            // leave blank
            ctx.fillStyle="white";
            ctx.fill();
            ctx.fillRect(row*25,col*25,25,25);
        }
        if(level[col][row]===1){
            // create block
            platforms.add(blocks,Block,row*40,col*40);
        }
        if(level[col][row]===2){
            // create player
            platforms.add(players,Player,row*40,col*40);
        }
        if(level[col][row]===3){
            // create lava
            platforms.add(lava,Lava,row*40,col*40);
        }
        if(level[col][row]===4){
            // create spike
            platforms.add(spikes,Spike,row*40,col*40);
        }
        if(level[col][row]===9){
            // create player
            platforms.add(portals,Portal,row*40,col*40);
        }
        
    }
  }
}
//does update loop when window loads
window.addEventListener("load", function(){
  updateLevel();
  //map();
  update();
});
 
canvas.addEventListener('click', function(evt) {
    var mousePos = getMousePos(canvas, evt);

    if (isInside(mousePos,280,350,200,100)&&Level===0) {
        Level=1;
        updateLevel();
    }   
    if (isInside(mousePos,280,350,200,100)&&Level===-1) {
        Level=0;
        LevelAmount=0;
        updateLevel();
    }  
}, false);

document.body.addEventListener("keydown", function(e) {
    keys[e.keyCode] = true;
});
 
document.body.addEventListener("keyup", function(e) {
    keys[e.keyCode] = false;
});
